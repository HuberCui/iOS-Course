# 系统相关
在这里记录了跟 Apple 相关操作系统中遇到的问题和记录。

### iOS中的内存区域划分，如下图所示：
<img src="https://i.loli.net/2018/04/08/5aca1d572b81b.jpeg" width = "100%" height = "100%" align=center />

### iOS中的推送相关，如下图所示：
<img src="https://i.loli.net/2018/04/08/5aca38905387f.jpeg" width = "100%" height = "100%" align=center />

### 程序的可执行文件类型：
* `ELF`：Linux下的可执行文件格式；
* `PE32/PE32+`：Windows下的可执行文件格式；
* `Mach-o`：Mac和iOS下的可执行文件格式，比如可执行文件、库文件、dsym文件、动态库、动态链接器

### 代码编译要经过的几个器件（C语言）：
* 预处理器：将.c 文件转化成 .i文件，使用的gcc命令是：gcc –E，对应于预处理命令cpp；
* 编译器：将.c/.h文件转换成.s文件，使用的gcc命令是：gcc –S，对应于编译命令 cc –S；
* 汇编器：将.s 文件转化成 .o文件，使用的gcc 命令是：gcc –c，对应于汇编命令是 as；
* 链接器：将.o文件转化成可执行程序，使用的gcc 命令是： gcc，对应于链接命令是 ld；
* 加载器：将可执行程序加载到内存并进行执行，loader和ld-linux.so。


### NSTimer
```obj
// 该方法默认是添加到 NSDefaultRunLoopMode
+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;

// 该方法需要手动添加到的NSRunLoop中
+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;

// 添加方法
[[NSRunLoop mainRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];
```

* NSDefaultRunLoopMode ：默认mode，当UIScrollView拖动时会影响。点击事件、普通回调事件、不滑动，是个默认状态、空闲状态，程序启动后，自动被切到这个 mode
* UITrackingRunLoopMode： 界面跟踪mode，用于scrollView跟踪触摸滑动，保证界面滑动时不受其它Mode影响
* UIInitializationRunLoopMode： 启动App时进入的第一个mode，启动完成后就不再使用。程序启动之后，私有，当出现第一个页面时就被切了。
* GSEventReceiveRunLoopMode：Graphic相关事件、接收系统事件内部的mode，通常用不到
* NSRunLoopCommonModes： 占位用的mode，不是真的mode，包含第一个和第二个。

scheduledTimerWithTimeInterval 使用该方法创建出来的timer默认加入到当前线程的RunLoop中，且模式为 NSDefaultRunLoopMode，如果当线程是主线程（UI线程），某些UI事件比如UIScrollView的拖动操作，会将Run Loop 切换成 NSEventTrackingRunLoopMode模式，在这个过程中，创建出来的timer的注册的事件是不会被执行的。需要把创建出来的 timer 使用 NSRunLoopCommonModes 模式添加到 Run Loop中，这个模式等效于 NSDefaultRunLoopMode和NSEventTrackingRunLoopMode的结合。

### NSCoding 协议和 runtime 的结合使用
iOS开发之NSCoding协议（使用runtime）：https://www.jianshu.com/p/b33bdbccfa57。正常对用NSCoding写数据持久化，如果该对象的属性较少直接开干没啥问题，但是如果是一个多属性的对象，那就得写死人了。直接用runtime的特性去遍历出当前对象的所有属性。

### 终结掉 self.var 和 _var 的纠结

`property = _var + setter + getter`。`self` 类似 `java` 中的 `this` 和 `C++` 中的 `self` ，`OC` 中 `self` 同样也具备相同的职能，只不过因为 `property` 机制的存在，事情并且不简单。

实例变量（成员变量）具有私有性，一般情况下只在类内部使用，为了方便给外界读写这个实例变量，就有了属性（`@property`），编译器会自动的（`@synthesize var = _var`）为我们生成对应的一个以下划线加属性名命名的实例变量、 `setter` 和 `getter` 方法，并且 `self.var` 会让 `var` 计数器 + 1，而 `_var` 不会。需要注意在 `var` 的 `getter` 方法中，我们必须要使用 `_var` 进行访问，如果还是 `self.var` 则会进入死循环，但是在 `setter` 中如果还是使用 `self.var` 则也会触发 `setter` 。懒加载中也需要用 `_var` 来访问实例变量。一句话就是，“获取 `var` 只能 `_var` ，赋值 `var` 可以 `_var` 和 `self.var`”。如果我们同时对 `var` 写了 `setter` 和 `getter` 方法，`@property` 机制将不会生效，我们要自己声明 `_var`

使用 `readonly` 关键字修饰后，编译器只会为我们生成 `getter`。如果一个属性被 `@dynamic` 修饰，则编译器不会为其自动生成对应的 `setter` 和 `getter`，如果没有我们没有自行编写 `getter` 和 `setter` ，将不会在编译器得到提醒，在程序运行时将会发生 `crash` 。我们还可以使用 `@dynamic` 替换到某个类中本来就存在的 `property`

在 `Swift` 中没有 `@property` 类似的机制，属性是否对外部可见通过 `private` 关键词进行决定，Swift 中的属性分为计算属性和存储属性。计算属性不直接存储值，而是通过 `getter` 和 `setter` 方法间接访问其它属性，类似 `OC` 中的属性。存储属性充当存储值的角色，可直接被外部访问，类似 `OC` 中的实例变量。

### UIView 和 CALayer 的区别
* **UIView 和 CALayer 一样都是 UI 操作的对象** ：两者都是 `NSObject` 的子类，发生在 UIView 上的操作本质上也发生在 CALayer 上。
* **UIView 是 CALayer 用于交互的对象** ：UIView 是 UIResponder 的子类（ UIResponder 是 NSObject 的子类），UIView 提供了很多 CALayer 交互上所没有的接口，其主要负责处理用户触发的各种操作。
* **CALayer 在图像和动画上渲染性能更好** ：正是因为 UIView 有冗余的交互接口，而且相比 CALayer 还有层级之分，而 CALayer 在无须处理交互时进行渲染，可以节省大量时间。

### layeroutIfNeeded ，layoutSubviews 和 setNeedsLayout 的区别

* **`layeroutIfNeeded`** ： 该方法一旦被调用，主线程会立即强制重新布局。它从当前视图开始，一直到完成所有子视图的布局；
* **`layoutSubviews`** ：该方法用于自定义视图尺寸。系统调用，开发者只能重写该方法，让系统在调整尺寸时能够按照开发者希望的效果进行布局。该方法主要用在屏幕旋转、滑动或触摸界面、修改子视图时被触发。
* **`setNeedsLayout`** ：与 `layoutSubviews` 方法作用类似，不同的是它不会立刻强制视图重新布局，而是在下一个布局周期才会触发更新。该方法主要用于多个视图布局先后更新的场景下。比如，在两个位置不断变化的点之间连一条线，该条线的布局就可以调用 `setNeedsLayout` 方法。

## 适配 iPad
### `UIAlertController` crash
详见：[https://stackoverflow.com/questions/31577140/uialertcontroller-is-crashed-ipad](https://stackoverflow.com/questions/31577140/uialertcontroller-is-crashed-ipad)

## 打开第三方 app 及被第三方 app 打开
如果能够保证这个 scheme 一定是存在的，可以直接执行：
```Objc
[[UIApplication sharedApplication] openURL:request.URL
                                   options:@{}
                         completionHandler:nil];
```

如果不能保证，以免其它特殊问题（我没遇到过），可以先 `canOpenURL` 判断一下：
```Objc
BOOL result = [[UIApplication sharedApplication] canOpenURL:request.URL];
if(result) {
    [[UIApplication sharedApplication] openURL:request.URL
                                        options:@{}
                              completionHandler:nil];
} else {
    // 是否需要提示？
}
```

执行 `canOpenURL` 方法，记得现在 `target` -> `Info` -> `Custom iOS Target Properties` 中添加字段 `LSApplicationQueriesSchemes`，类型为 `Array`，在 `item` 中添加对应需要打开的 app scheme 即可。

在 URL Types 中写的 scheme 指的是被其它 app 回调我方 app 时的标识符。

### `removeFromSuperView` 删除 `View`
我们经常会使用 `[UIView removeFromSuperView]` 方法把一个 `UIView` 及其子类（下文称 `ViewA`）从当前视图中进行移除，当我们执行这个操作时，潜意识里是想把这个视图彻底从当前页面上进行移除，但是这个方法只能保证把 `ViewA` 从当前视图上进行移除，并不能保证该 `ViewA` 真的被移除”，内存中还是存在 `ViewA` 。

还需要执行 `ViewA = nil`

### 如何修改 `UIAlertAction` 的文字颜色
`applyAction.setValue(UIColor.lightGray, forKey: "_titleTextColor")`

### 关于使用友盟推送收不到 push 消息的原因之一
可以使用友盟后台进行“推送测试”，如果是自建了集成友盟推送 SDK 的后台，进行“推送测试”的话，需要把 app 进行构建，通过安装并使用构建出来的 `ipa` 包才能够收到自建集成了友盟推送 SDK 的后台推送。

注意：测试设备例如 iPhone、iPad 等设备请登陆 **Apple ID**，否则 app 中集成友盟推送 SDK 将无法对该测试设备进行 `device Token` 的生成，也即无法推送至友盟中心。

### 什么是元编程
元编程。一件事情通过正常编程去做到是「正常编程」，元编程是通过编程的方法做到其他需要编程的事情，可以理解为「元编程」的本质上在做一个新的 DSL。`@property` 就是一个「元编程」思路。

### 统计启动耗时。统计启动到初始化结束的耗时，需要的是对关键业务的统计。


### 自旋锁
当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该现场将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会推出循环。

存在的问题：如果某个线程持有锁的时间过长，就会导致其他等待获取锁的线程进入循环等待，消耗 CPU。

 优点：自旋锁不会使线程状态发生切换，其会一直处于用户态，线程一直都是 active 的，不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快。非自旋锁在获取不到锁时会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换，因为线程被阻塞后便进入「内核调度状态」，会导致系统在用户态和内核态之间来回切换。

可查看：https://zhuanlan.zhihu.com/p/40729293

### CocoaPods 都做了什么？
首先明确一点，pods 是一个依赖管理工具，能够解析出用在 `Podfile` 文件中的配置信息，解析配置信息的过程不是特别复杂， 但解析的逻辑代码量一点都不小，考虑了很多的 case，尤其是依赖解析部分，自建了一个依赖图算法完成各个依赖库之间的重复依赖关系。

pods 是基于 `ruby` 的一个依赖管理工具，虽然 `Podfile` 写起来给人感觉一点都不像是写代码，而是在写一个描述文档，这是因为 `ruby` 的方法调用可以不写方法调用时的左右括号，而且也支持 block 的调用（与 OC block 不一致）。解析出依赖库后，会调用一个下载器，下载器会根据当前的执行命令是 `pod install` 还是 `pod update` 来决定下载器的入参。[详情可见](https://github.com/draveness/analyze/blob/master/contents/CocoaPods/CocoaPods%20都做了什么？.md)

### 如何造一个 Router
看了头条的 Router 实现大概流程，在开始的做法是通过 `.strings` 文件填写好 URL 做好映射，再通过 OC 的反射机制把字符串反射为类，现在虽然已经修改为了不需要引入配置文件，之前在应用初始化的时候就能初始化好了 Router，但实际上的做法还是基于反射。

个人认为 router 的好处在于能够应对多个 type 的跳转。


### 打包过程
* 源代码编译
* 静态库链接
* 资源编译、优化、导入
* 配置文件生成
* 签名打包

### 编译
编译器前端部分主要负责把「编程语言」翻译成「平台无关语言」，编译器后端主要作用是把「平台无关语言」翻译成「平台相关语言」
￼![编译的基本架构](https://i.loli.net/2019/07/12/5d289cf7587b291374.png)

### LLVM 架构
![LLVM 架构](https://i.loli.net/2019/07/12/5d289da9e2ebb56408.png)

### Clang
* 基于 LLVM 的编译器前端
* 基于 LLVM 的 C 语言编译工具集，兼容 GCC

### 预处理
* 引入头文件
* 预处理指令
* 去除注释
* 宏定义展开。`clang -E -fmodules test.m`，命令执行后效果：
![宏定义展开](https://i.loli.net/2019/07/12/5d289e1f7e96039474.png)

###  Lexer 词法解析
`clang -fsyntax-only -fmodules -Xclang -dump-tokens text.m`，命令执行效果：

![Lexer 词法解析](https://i.loli.net/2019/07/12/5d289e791cfa994692.png)

### AST（抽象语法树）
`clang -fsyntax-only -fmodules -Xclang -ast-dump`

![抽象语法树](https://i.loli.net/2019/07/12/5d289eccd5b6a73351.png)


### iOS 不与磁盘交换
所以脏页面在 Apple 的移动设备上成本更高。无论使用多少。脏页面永远不会写入磁盘，所以 IOS 必须更积极地交换干净页面（可执行代码、映射文件）或终止进程。